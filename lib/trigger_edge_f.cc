/* -*- c++ -*- */
/*
 * Copyright 2011 Free Software Foundation, Inc.
 * 
 * This file is part of gr-eventstream
 * 
 * gr-eventstream is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3, or (at your option)
 * any later version.
 * 
 * gr-eventstream is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with gr-eventstream; see the file COPYING.  If not, write to
 * the Free Software Foundation, Inc., 51 Franklin Street,
 * Boston, MA 02110-1301, USA.
 */

/*
 * config.h is generated by configure.  It contains the results
 * of probing for features, options etc.  It should be the first
 * file included in your .cc file.
 */
#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <eventstream/api.h>
#include <gnuradio/io_signature.h>
#include <stdio.h>
#include <string.h>

namespace gr {
namespace eventstream {
/*
 * Create a new instance of eventstream_trigger_edge_f and return
 * a boost shared_ptr.  This is effectively the public constructor.
 */
eventstream_trigger_edge_f_sptr 
eventstream_make_trigger_edge_f (float thresh, int length, int lookback, int itemsize, int guard) {
  return eventstream_trigger_edge_f_sptr (new eventstream_trigger_edge_f (thresh,length,lookback,itemsize,guard));

}

/*
 * Specify constraints on number of input and output streams.
 * This info is used to construct the input and output signatures
 * (2nd & 3rd args to gr::block's constructor).  The input and
 * output signatures are used by the runtime system to
 * check that a valid number and type of inputs and outputs
 * are connected to this block.  In this case, we accept
 * only 1 input and 1 output.
 */
static const int MIN_IN = 1;	// mininum number of input streams
static const int MAX_IN = 2;	// maximum number of input streams
static const int MIN_OUT = 0;	// minimum number of output streams
static const int MAX_OUT = 1;	// maximum number of output streams

eventstream_trigger_edge_f::eventstream_trigger_edge_f (float thresh, int length, int lookback, int itemsize, int guard)
  : 
    d_guard(guard),
    d_lasttrigger(0),
    d_thresh(thresh), 
    gr::sync_block ("eventstream_trigger_edge_f",
        gr::io_signature::make2(MIN_IN, MAX_IN, sizeof(float), itemsize),
        gr::io_signature::make(MIN_OUT,MAX_OUT, itemsize))
{
    register_handler("edge_event");
    d_time = 0;
    d_length = length;
    d_lookback = lookback;
}

eventstream_trigger_edge_f::~eventstream_trigger_edge_f ()
{
}

int 
eventstream_trigger_edge_f::work (int noutput_items,
			gr_vector_const_void_star &input_items,
			gr_vector_void_star &output_items)
{
  float *in = (float*) input_items[0];
   
  // make sure we have passthrough input if we have passthrough output 
  if((output_items.size() == 1 && input_items.size() == 1) ){
        throw std::runtime_error("if passthrough output is connected, input must be!");
        }

  // copy input to output if output connected
  if(output_items.size() == 1 && input_items.size() == 2){
    int itemsize = input_signature()->sizeof_stream_item(1);
    void *ii = (void*) input_items[1];
    void *oi = (void*) output_items[0];
    memcpy(oi, ii, noutput_items*itemsize);
  }

  d_lastval = (d_time==0)?in[0]:d_lastval;
  if(d_time == 0){ d_lastval = in[0]; }
  
  for(int i=0; i<noutput_items; i++){
    //printf("in[i]=%f, d_thresh=%f, d_lastval=%f\n", in[i], d_thresh, d_lastval);
    if((in[i] > d_thresh) && (d_lastval < d_thresh) && ((d_lasttrigger==0)||(d_lasttrigger + d_guard <= d_time + i))){
        // create an event at the appropriate time,
        //  factoring lookback and event length specified in constructor
        if(i+d_time < d_lookback){
            printf("WARNING: d_time < d_lookback, spawning event at time zero.\n");
        }
        //pmt_t e1 = event_create( event_type(0), d_time-d_lookback, d_length );
        uint64_t event_time = (i+d_time)>d_lookback?i+d_time-d_lookback:0;
        pmt_t e1 = event_create( pmt::mp("edge_event"), event_time, d_length );
        //std::cout << "creating event @ time " << event_time << ", length = " << d_length << "\n";
    
        // add event to our queue
        message_port_pub(pmt::mp("which_stream"), e1);

        // record our last trigger
        d_lasttrigger = event_time;
    }
    d_lastval = in[i];
    //d_time++;
  }
  
  // consume the current input items
  d_time += noutput_items;
  return noutput_items;
  
}

void 
eventstream_trigger_edge_f::set_thresh(float thresh)
{
  d_thresh = thresh;
}
}
}

